# -*- coding: utf-8 -*-
"""NetFlow.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cWYwPJsziQMb0U7wW3AtkB53D0wfdajN
"""

import torch
import torch.nn as nn
import pandas as pd
import numpy as np
from google.colab import drive
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import classification_report, confusion_matrix, roc_auc_score

drive.mount('/content/drive')

labeled_df = pd.read_csv('/content/drive/MyDrive/NetFlowDatasets/anomaly detection final/labeled_dataset.csv')
labeled_df.head()

labeled_df.columns

df = labeled_df.drop(columns=['Unnamed: 0'], errors='ignore')
X = df.drop(columns=['Label','Class'], errors='ignore')
y_true = (df['Class'] == 'Attack').astype(int)  # Benign=0, Attack=1

scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

X_train = X_scaled[y_true == 0]

device = 'cuda' if torch.cuda.is_available() else 'cpu'
X_train = torch.tensor(X_train, dtype=torch.float32).to(device)
X_tensor = torch.tensor(X_scaled, dtype=torch.float32).to(device)

class DeepAE(nn.Module):
    def __init__(self, in_dim):
        super().__init__()
        self.encoder = nn.Sequential(
            nn.Linear(in_dim, 512),
            nn.ReLU(),
            nn.Linear(512, 128),
            nn.ReLU(),
            nn.Linear(128, 32),
            nn.ReLU()
        )
        self.decoder = nn.Sequential(
            nn.Linear(32, 128),
            nn.ReLU(),
            nn.Linear(128, 512),
            nn.ReLU(),
            nn.Linear(512, in_dim)
        )

    def forward(self, x):
        z = self.encoder(x)
        out = self.decoder(z)
        return out

in_dim = X_train.shape[1]
model = DeepAE(in_dim).to(device)
criterion = nn.MSELoss()
optimizer = torch.optim.Adam(model.parameters(), lr=1e-3)

X_train.shape[1]

from torch.utils.data import DataLoader, TensorDataset

batch_size = 256
train_loader = DataLoader(TensorDataset(X_train), batch_size=batch_size, shuffle=True)

epochs = 100
for epoch in range(epochs):
    model.train()
    epoch_loss = 0
    for batch in train_loader:
        x_batch = batch[0]
        optimizer.zero_grad()
        recon = model(x_batch)
        loss = criterion(recon, x_batch)
        loss.backward()
        optimizer.step()
        epoch_loss += loss.item() * x_batch.size(0)
    epoch_loss /= len(X_train)
    if epoch % 10 == 0:
        print(f"Epoch {epoch} | Loss: {epoch_loss:.6f}")

list(train_loader[0][0])

model.eval()
with torch.no_grad():
    recon_all = model(X_tensor)
    errors = torch.mean((recon_all - X_tensor) ** 2, dim=1).cpu().numpy()

threshold = np.percentile(errors[y_true == 0], 95)  # 5% بالایی Benign = threshold
print("Threshold:", threshold)

y_pred = (errors > threshold).astype(int)

print("Confusion Matrix:")
print(confusion_matrix(y_true, y_pred))
print("\nClassification Report:")
print(classification_report(y_true, y_pred))
print("AUC:", roc_auc_score(y_true, errors))
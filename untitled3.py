# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1b-3ozRo164jayU904fyKnqLKKwcTRG9_
"""

import torch
import torch.nn as nn
import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import classification_report , confusion_matrix , roc_auc_score
import torch.optim as optim

!pip install -q qdown
import gdown

gdown.download('https://drive.google.com/uc?id=1eoRN9C6OTaCoEPwxIzzgEmS4AZ5W9aut' ,'labeled_dataset.csv' ,quiet=True  )

df = pd.read_csv('/content/labeled_dataset.csv')

df.head()

df.columns

df.drop(columns=['Unnamed: 0'] ,inplace = True)

x = df.drop(columns=['Label', 'Class'])
y_true = df['Class']
y_true = (y_true == 'Attack').astype(int)
y_true

scaler = StandardScaler()
X_scaled = scaler.fit_transform(x)

x_train = X_scaled[y_true == 0]

device = 'cuda' if torch.cuda.is_available() else 'cpu'

x_train = torch.tensor(x_train , dtype = torch.float32).to(device)
x_tensor= torch.tensor(X_scaled , dtype = torch.float32).to(device)

class DeepSVDD(nn.Module):
    def __init__(self, in_dim, hid=128, rep=32):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(in_dim, hid),
            nn.ReLU(),
            nn.Linear(hid, rep)
        )
    def forward(self, x):
        return self.net(x)

in_dim = x_train.shape[1]
net = DeepSVDD(in_dim).to(device)

def init_center_c(loader, net):
    c = torch.zeros(32, device=device)
    n = 0
    with torch.no_grad():
        for batch in loader:
            z = net(batch)
            c += z.sum(dim=0)
            n += z.shape[0]
    c /= n
    # if close to zero, push away
    eps = 1e-4
    c[torch.abs(c) < eps] = eps
    return c

train_loader = torch.utils.data.DataLoader(
    x_train, batch_size=512, shuffle=True
)
optimizer = optim.Adam(net.parameters(), lr=1e-4)

# اول c را بعد از یک پاس init می‌کنیم
net.eval()
c = init_center_c(train_loader, net)

net.train()
for epoch in range(30):
    for batch in train_loader:
        z = net(batch)
        dist = torch.sum((z - c)**2, dim=1)
        loss = torch.mean(dist)

        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
    print(f"epoch {epoch+1}  loss={loss.item():.5f}")

net.eval()
with torch.no_grad():
    z_all = net(x_tensor)
    dist_all = torch.sum((z_all - c)**2, dim=1)
    anomaly_score = dist_all.cpu().numpy()

scores = anomaly_score
true = y_true.cpu().numpy() if torch.is_tensor(y_true) else y_true

thr = np.median(scores[y_true==0])   # threshold on benign

y_pred = (scores > thr).astype(int)  # > => attack

print("Confusion Matrix:")
print(confusion_matrix(true, y_pred))

print("\nClassification Report:")
print(classification_report(true, y_pred))

print("AUC:", roc_auc_score(true, scores))

# 1) load & preprocess
# 2) split benign train
# 3) train Deep-SVDD
# 4) compute anomaly_score = ...

# 5) ---- اینجا کد Threshold و Metrics را اضافه کن ----
import numpy as np
from sklearn.metrics import f1_score, confusion_matrix, classification_report, roc_auc_score

scores = anomaly_score
true = y_true.cpu().numpy() if torch.is_tensor(y_true) else y_true

thrs = np.quantile(scores, np.linspace(0,1,200))
best_f1 = -1
best_thr = None

for t in thrs:
    pred = (scores > t).astype(int)
    f1 = f1_score(true, pred)
    if f1 > best_f1:
        best_f1 = f1
        best_thr = t

y_pred = (scores > best_thr).astype(int)

print("Best Threshold:", best_thr)
print("F1:", best_f1)
print("\nConfusion Matrix:")
print(confusion_matrix(true, y_pred))
print("\nClassification Report:")
print(classification_report(true, y_pred))
print("AUC:", roc_auc_score(true, scores))

import numpy as np
from sklearn.metrics import precision_score, confusion_matrix, classification_report, roc_auc_score

scores = anomaly_score
true = y_true.cpu().numpy() if torch.is_tensor(y_true) else y_true

thrs = np.quantile(scores, np.linspace(0,1,200))
best_prec = -1
best_thr = None

for t in thrs:
    pred = (scores > t).astype(int)
    prec = precision_score(true, pred)
    if prec > best_prec:
        best_prec = prec
        best_thr = t

y_pred = (scores > best_thr).astype(int)

print("Best Threshold:", best_thr)
print("Precision:", best_prec)
print("\nConfusion Matrix:")
print(confusion_matrix(true, y_pred))
print("\nClassification Report:")
print(classification_report(true, y_pred))
print("AUC:", roc_auc_score(true, scores))

confusion_matrix(true, y_pred)